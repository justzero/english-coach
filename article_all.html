<div class="grid_7 omega" id="post" style="width: 675px"><p>I’ve had an unusual number of interesting conversations spin out of my previous article documenting that <a href="http://sealedabstract.com/rants/mobile-web-apps-are-slow/" title="Mobile web apps are slow">mobile web apps are slow</a>. &nbsp;This has sparked some discussion, both online and IRL. &nbsp;But sadly, the discussion has not been as… <em>fact-based</em> as I would like.</p><p>So what I’m going to do in this post is try to bring some actual&nbsp;<em>evidence</em> to bear on the problem, instead of just doing the shouting match thing. &nbsp;You’ll see benchmarks, you’ll hear from experts, you’ll even read honest-to-God <em>journal papers</em> on point. &nbsp;<strong>There are–and this is not a joke–over 100 citations in this blog post.</strong> I’m not going to guarantee that this article will convince you, nor even that absolutely everything in here is totally correct–it’s impossible to do in an article this size–but I can guarantee this is the most complete and comprehensive treatment of the idea that many iOS developers have–that mobile web apps are slow and will continue to be slow for the forseeable future.</p><p>Now I am going to warn you–this is a very freaking long article, weighing in at very nearly 10k words. &nbsp;That is by design. &nbsp;I have recently come out in favor of articles that are good <a href="http://sealedabstract.com/rants/hey-programmers-we-need-to-talk/">over articles that are popular</a>. This is my attempt at the former, and my attempt to practice what I have previously preached: that we should incentivize good, evidence-based, interesting discussion and discourage writing witty comments.</p><p>I write in part because this topic has been discussed–endlessly–in soundbyte form. &nbsp;This is not Yet Another Bikeshed Article, so if you are looking for that 30-second buzz of “no really, web apps suck!” vs “No they don’t!” this is not the article for you. &nbsp;(<a onclick="javascript:pageTracker._trackPageview('/outgoing/daringfireball.net/2013/04/web_apps_native_apps');" href="http://daringfireball.net/2013/04/web_apps_native_apps">Go</a> <a onclick="javascript:pageTracker._trackPageview('/outgoing/www.wired.com/insights/2012/11/native-apps-vs-mobile-web/');" href="http://www.wired.com/insights/2012/11/native-apps-vs-mobile-web/">read</a> <a onclick="javascript:pageTracker._trackPageview('/outgoing/www.businessinsider.com/battle-between-html5-vs-native-apps-2013-5');" href="http://www.businessinsider.com/battle-between-html5-vs-native-apps-2013-5">one</a> <a onclick="javascript:pageTracker._trackPageview('/outgoing/www.businessinsider.com/html5-vs-native-apps-for-mobile-2013-4?op=1');" href="http://www.businessinsider.com/html5-vs-native-apps-for-mobile-2013-4?op=1">of</a> <a onclick="javascript:pageTracker._trackPageview('/outgoing/venturebeat.com/2013/04/17/linkedin-mobile-web-breakup/');" href="http://venturebeat.com/2013/04/17/linkedin-mobile-web-breakup/">these</a>&nbsp;<a onclick="javascript:pageTracker._trackPageview('/outgoing/mashable.com/2012/09/12/web-vs-native-apps/');" href="http://mashable.com/2012/09/12/web-vs-native-apps/">oh</a> <a onclick="javascript:pageTracker._trackPageview('/outgoing/paidcontent.org/2013/04/17/the-definitive-answer-of-web-or-apps-as-the-future-of-mobile-content-it-depends/');" href="http://paidcontent.org/2013/04/17/the-definitive-answer-of-web-or-apps-as-the-future-of-mobile-content-it-depends/">no</a> <a onclick="javascript:pageTracker._trackPageview('/outgoing/www.forbes.com/sites/ciocentral/2013/01/23/html5-vs-native-mobile-apps-myths-and-misconceptions/');" href="http://www.forbes.com/sites/ciocentral/2013/01/23/html5-vs-native-mobile-apps-myths-and-misconceptions/">make</a> <a onclick="javascript:pageTracker._trackPageview('/outgoing/www.guardian.co.uk/media-network/media-network-blog/2013/feb/07/html5-native-apple-android-strategy');" href="http://www.guardian.co.uk/media-network/media-network-blog/2013/feb/07/html5-native-apple-android-strategy">it</a> <a onclick="javascript:pageTracker._trackPageview('/outgoing/blog.mobpartner.com/2013/04/16/mobile-web-native-applications/');" href="http://blog.mobpartner.com/2013/04/16/mobile-web-native-applications/">stop</a>&nbsp;<a onclick="javascript:pageTracker._trackPageview('/outgoing/www.themusicvoid.com/2013/04/mobile-content-battle-native-apps-vs-html5-the-browser/');" href="http://www.themusicvoid.com/2013/04/mobile-content-battle-native-apps-vs-html5-the-browser/">can’t</a>&nbsp;<a onclick="javascript:pageTracker._trackPageview('/outgoing/searchcloudapplications.techtarget.com/feature/Mobile-cloud-apps-vs-native-apps-The-developers-perspective');" href="http://searchcloudapplications.techtarget.com/feature/Mobile-cloud-apps-vs-native-apps-The-developers-perspective">breathe</a>&nbsp;<a onclick="javascript:pageTracker._trackPageview('/outgoing/news.ycombinator.com/item?id=4838302');" href="https://news.ycombinator.com/item?id=4838302">not</a> <a onclick="javascript:pageTracker._trackPageview('/outgoing/news.ycombinator.com/item?id=2507453');" href="https://news.ycombinator.com/item?id=2507453">HN</a> <a onclick="javascript:pageTracker._trackPageview('/outgoing/news.ycombinator.com/item?id=4834234');" href="https://news.ycombinator.com/item?id=4834234">too</a>&nbsp;<a onclick="javascript:pageTracker._trackPageview('/outgoing/news.ycombinator.com/item?id=1012559');" href="https://news.ycombinator.com/item?id=1012559">I</a> <a onclick="javascript:pageTracker._trackPageview('/outgoing/reefpoints.dockyard.com/2011/11/10/mobile-web-apps.html');" href="http://reefpoints.dockyard.com/2011/11/10/mobile-web-apps.html">can’t</a> <a onclick="javascript:pageTracker._trackPageview('/outgoing/lists.w3.org/Archives/Public/public-coremob/2012Sep/0021.html');" href="http://lists.w3.org/Archives/Public/public-coremob/2012Sep/0021.html">do</a> <a onclick="javascript:pageTracker._trackPageview('/outgoing/reefpoints.dockyard.com/2011/11/10/mobile-web-apps.html');" href="http://reefpoints.dockyard.com/2011/11/10/mobile-web-apps.html">this</a> <a onclick="javascript:pageTracker._trackPageview('/outgoing/venturebeat.com/2011/11/09/mobile-web/');" href="http://venturebeat.com/2011/11/09/mobile-web/">anymore</a>&nbsp;<a onclick="javascript:pageTracker._trackPageview('/outgoing/www.guardian.co.uk/technology/blog/2011/nov/03/will-html5-replace-native-apps');" href="http://www.guardian.co.uk/technology/blog/2011/nov/03/will-html5-replace-native-apps">please</a> <a onclick="javascript:pageTracker._trackPageview('/outgoing/www.sencha.com/blog/the-making-of-fastbook-an-html5-love-story');" href="http://www.sencha.com/blog/the-making-of-fastbook-an-html5-love-story">just</a> <a onclick="javascript:pageTracker._trackPageview('/outgoing/blog.tobie.me/post/31366970040/when-im-introspective-about-the-last-few-years-i');" href="http://blog.tobie.me/post/31366970040/when-im-introspective-about-the-last-few-years-i">stop</a>&nbsp;<a onclick="javascript:pageTracker._trackPageview('/outgoing/blog.suthakamal.com/2012/08/go-native-html5-is-going-to-lag-for.html');" href="http://blog.suthakamal.com/2012/08/go-native-html5-is-going-to-lag-for.html">so</a> <a onclick="javascript:pageTracker._trackPageview('/outgoing/www.ericsink.com/entries/html5_vs_native_apps.html');" href="http://www.ericsink.com/entries/html5_vs_native_apps.html">many</a> <a onclick="javascript:pageTracker._trackPageview('/outgoing/hnpod.com/episodes/html5-vs-native-apps');" href="http://hnpod.com/episodes/html5-vs-native-apps">opinions</a> <a onclick="javascript:pageTracker._trackPageview('/outgoing/designmind.frogdesign.com/blog/unraveling-html5-vs-native.html');" href="http://designmind.frogdesign.com/blog/unraveling-html5-vs-native.html">so</a> <a onclick="javascript:pageTracker._trackPageview('/outgoing/techcrunch.com/2011/02/09/html5-versus-native-apps/');" href="http://techcrunch.com/2011/02/09/html5-versus-native-apps/">few</a> <a onclick="javascript:pageTracker._trackPageview('/outgoing/news.ycombinator.com/item?id=5254289');" href="https://news.ycombinator.com/item?id=5254289">facts</a> <a onclick="javascript:pageTracker._trackPageview('/outgoing/thenextweb.com/dd/2013/03/18/accounting-software-startup-xero-ditches-html5-in-favor-of-native-ios-and-android-apps/');" href="http://thenextweb.com/dd/2013/03/18/accounting-software-startup-xero-ditches-html5-in-favor-of-native-ios-and-android-apps/">I</a> <a onclick="javascript:pageTracker._trackPageview('/outgoing/www.deck.cc/native_vs_html5_mobile_applications.html');" href="http://www.deck.cc/native_vs_html5_mobile_applications.html">can</a> <a onclick="javascript:pageTracker._trackPageview('/outgoing/gkosev.blogspot.com/2012/08/why-native-development-sucks-and-html5.html');" href="http://gkosev.blogspot.com/2012/08/why-native-development-sucks-and-html5.html">go</a> <a onclick="javascript:pageTracker._trackPageview('/outgoing/news.ycombinator.com/item?id=1903074');" href="https://news.ycombinator.com/item?id=1903074">on</a>). &nbsp;On the other hand, as best as I can tell, <em>there is no comprehensive, informed, reasonable discussion of this topic happening anywhere</em>. It may prove to be a very stupid idea, but this article is my attempt to talk reasonably about a topic that has so far spawned 100% unreasonable flamewar-filled bikeshed discussions. In my defense, I have chosen to believe the problem has more to do with people who <em>can</em> discuss better and simply <em>don’t</em>, than anything to do with the subject matter. I suppose we’ll find out.</p><p>So if you are trying to figure out exactly&nbsp;<em>what brand of crazy</em> all your native developer friends are on for continuing to write the evil native applications on the cusp of the open web revolution, or <em>whatever</em>, then bookmark this page, make yourself a cup of coffee, clear an afternoon, find a comfy chair, and then we’ll both be ready.</p><h2>A quick review</h2><p>My <a href="http://sealedabstract.com/rants/mobile-web-apps-are-slow/" title="Mobile web apps are slow">previous blog post documented</a>, based on SunSpider benchmarks, that the state of the world, today, is that mobile web apps are slow.</p><blockquote><p>Now, if what you mean by “web app” is “website with a button or two”, you can tell all the fancypants benchmarks like SunSpider to take a hike. &nbsp;But if you mean “light word processing, light photo editing, local storage, and animations between screens” then you don’t want to be doing that in a web app on ARM unless you have a death wish.</p></blockquote><p>You should really go read that article, but I will show you the benchmark anyway: <a onclick="javascript:pageTracker._trackPageview('/downloads/wp-content/uploads/2013/01/Screen-Shot-2013-01-05-at-3.59.05-AM.png');" href="http://sealedabstract.com/wp-content/uploads/2013/01/Screen-Shot-2013-01-05-at-3.59.05-AM.png"><img class="alignnone size-full wp-image-1574" alt="Screen Shot 2013-01-05 at 3.59.05 AM" src="http://sealedabstract.com/wp-content/uploads/2013/01/Screen-Shot-2013-01-05-at-3.59.05-AM.png" width="700"></a></p><p>Essentially there are three categories of criticism about this benchmark:</p><ol><li>The fact that JS is slower than native code is not news: everybody learned this in CS1 when they talked about compiled vs JIT vs interpreted languages. &nbsp;The question is whether it is appreciably slower in some way that actually matters for the kind of software you are writing, and benchmarks like these fail to address that problem one way or the other.</li><li>Yes JS is slower and yes it matters, but it keeps getting faster and so one day soon we will find ourselves in case #1 where it is no longer appreciably slower, so start investing in JS now.</li><li>I write Python/PHP/Ruby server-side code and I have no idea what you guys keep going on about. &nbsp;I know that my servers are faster than your mobile devices, but surely if I am pretty comfortable supporting X,000 users using an&nbsp;<strong>actually</strong> interpreted language, you guys can figure out how to support a single user in a language with a high-performance JIT? &nbsp;How hard can it be?</li></ol><p>I have the rather lofty goal of refuting all three claims in this article: yes, JS is slow in a way that actually matters, no, it will not get appreciably faster in the near future, and no, your experience with server-side programming does not adequately prepare you to “think small” and correctly reason about mobile performance.</p><p>But the real elephant in the room here is that in all these articles on this subject, rarely does anyone actually quantify&nbsp;<strong>how slow</strong> JS is or provide any sort of&nbsp;<strong>actually useful standard of comparison</strong>. &nbsp;(You know… <em>slow relative to what?</em>) &nbsp;To correct this, I will develop, in this article, not just&nbsp;<strong>one</strong> useful equivalency for JavaScript performance–but&nbsp;<strong>three of them</strong>. &nbsp;So I’m not only going to argue the “traditional hymns” of “wa wa JS is slow for arbitrary case”, but I’m going to quantify exactly how slow it is, and compare it to a wide variety of things in your real-life programming experience so that, when you are faced with your own platform decision, you can do your own back-of-the-napkin math on whether or not JavaScript is feasible for solving your own particular problem.</p><h2>Okay, but how does JS performance compare to native performance exactly?</h2><p>It’s a good question. &nbsp;To answer it, I grabbed an <a onclick="javascript:pageTracker._trackPageview('/outgoing/benchmarksgame.alioth.debian.org/u32/program.php?test=spectralnorm&amp;lang=v8&amp;id=2');" href="http://benchmarksgame.alioth.debian.org/u32/program.php?test=spectralnorm&amp;lang=v8&amp;id=2">arbitrary benchmark</a> from The Benchmarks Game. &nbsp;I then found an older C program that does the same benchmark (older since the newer ones have a lot of x86-specific intrinsics). &nbsp;Then benchmarked Nitro against LLVM on my trusty iPhone 4S. &nbsp;All the code is <a onclick="javascript:pageTracker._trackPageview('/outgoing/github.com/drewcrawford/bench');" href="https://github.com/drewcrawford/bench">up on GitHub</a>.</p><p>Now this is all very arbitrary–but the code you’re running in real life is equally arbitrary. &nbsp;If you want a better experiment, go run one. &nbsp;This is just the experiment I ran, because there aren’t any other experiments that compare LLVM to Nitro that exist.</p><p>Anyway, in this synthetic benchmark, LLVM is consistently 4.5x faster than Nitro:</p><p><a onclick="javascript:pageTracker._trackPageview('/downloads/wp-content/uploads/2013/05/Screen-Shot-2013-05-14-at-5.32.06-AM.png');" href="http://sealedabstract.com/wp-content/uploads/2013/05/Screen-Shot-2013-05-14-at-5.32.06-AM.png"><img class="alignnone  wp-image-1716" alt="Screen Shot 2013-05-14 at 5.32.06 AM" src="http://sealedabstract.com/wp-content/uploads/2013/05/Screen-Shot-2013-05-14-at-5.32.06-AM.png" width="694" height="422"></a></p><p>So if you are wondering “How much faster is my CPU-bound function in native code instead of Nitro JS” the answer is about 5x faster. This result is roughly consistent with the Benchmarks Game’s results with x86/GCC/V8. &nbsp;<a onclick="javascript:pageTracker._trackPageview('/outgoing/benchmarksgame.alioth.debian.org/u32/benchmark.php?test=all&amp;lang=v8&amp;lang2=gcc&amp;data=u32');" href="http://benchmarksgame.alioth.debian.org/u32/benchmark.php?test=all&amp;lang=v8&amp;lang2=gcc&amp;data=u32">They claim</a> that GCC/x86 is generally between 2x and 9x faster than V8/x86. &nbsp;So the result seems in the right ballpark, and also seems consistent no matter if you are on ARM or x86.</p><h1>But isn’t 1/5 performance good enough for anyone?</h1><p>It’s good enough on x86. &nbsp;How CPU-intensive is rendering a spreadsheet, really? &nbsp;It’s not really that hard. Problem is, ARM isn’t x86.</p><p><a onclick="javascript:pageTracker._trackPageview('/outgoing/browser.primatelabs.com/geekbench2/compare/1952237/1952292');" href="http://browser.primatelabs.com/geekbench2/compare/1952237/1952292">According to GeekBench</a>, the latest MBP against the latest iPhone is a full factor of 10 apart. &nbsp;So that’s okay–spreadsheets really aren’t that hard. &nbsp;We can live with 10% performance. But then you want to divide&nbsp;<strong>that</strong> by five? &nbsp;Woah there buddy. &nbsp;Now we’re down to 2% of desktop performance. &nbsp;(I’m playing fast-and-loose with the units, but we’re dealing with orders of magnitude here. &nbsp;Close enough.)</p><p>Okay, but how hard is word processing, <em>really</em>? &nbsp;Couldn’t we do it on like an m68k with one coprocessor tied behind its back? Well, this is an answerable question. &nbsp;You may not recall, but Google Docs’ realtime collaboration was not, in fact, a launch feature. &nbsp;They did a massive rewrite that added it in&nbsp;<a onclick="javascript:pageTracker._trackPageview('/outgoing/googledocs.blogspot.com/2010/04/new-google-docs.html');" href="http://googledocs.blogspot.com/2010/04/new-google-docs.html">April 2010. </a>&nbsp;Let’s see what browser performance <a onclick="javascript:pageTracker._trackPageview('/outgoing/lowlymarine.blogspot.com/2010/06/brief-browser-battle-sunspider.html');" href="http://lowlymarine.blogspot.com/2010/06/brief-browser-battle-sunspider.html">looked like in 2010</a>. <a onclick="javascript:pageTracker._trackPageview('/downloads/wp-content/uploads/2013/05/BrowserCompChart1-9-6-107.png');" href="http://sealedabstract.com/wp-content/uploads/2013/05/BrowserCompChart1-9-6-107.png"><img class="alignnone  wp-image-1717" alt="BrowserCompChart1 9-6-10[7]" src="http://sealedabstract.com/wp-content/uploads/2013/05/BrowserCompChart1-9-6-107.png" width="731" height="440"></a></p><p>What should be plainly obvious from this chart is that the iPhone 4S is not at all competitive with web browsers around the time that Google Docs did real-time collaboration. &nbsp;Well, it’s competitive with IE8. &nbsp;Congratulations on that.</p><p>Let’s look at another serious JavaScript application: Google Wave. &nbsp;Wave never supported IE8–<a onclick="javascript:pageTracker._trackPageview('/outgoing/googlewavedev.blogspot.com/2009/09/google-wave-in-internet-explorer.html');" href="http://googlewavedev.blogspot.com/2009/09/google-wave-in-internet-explorer.html">according to Google</a>–because it was too slow.</p><div id="attachment_1718" class="wp-caption alignnone size-full wp-image-1718" style="width:400px"><img class="size-full wp-image-1718" alt="Notice how all these browsers bench faster than the iPhone 4S?" src="http://sealedabstract.com/wp-content/uploads/2013/05/cf-in-ie.png" width="400" height="312"><p class="wp-caption-text">Notice how all these browsers bench faster than the iPhone 4S?</p></div><p>Notice how all the supported browsers bench below 1000, and the one that scores 3800 is excluded for being too slow? &nbsp;The iPhone benches 2400. &nbsp;It, just like IE8, isn’t fast enough to run Wave.</p><p>Just to be clear: <strong>is possible to do real-time collaboration on on a mobile device</strong>. &nbsp;It just isn’t possible to do it <strong>in JavaScript</strong>. &nbsp;The performance gap between native and web apps is comparable to the performance gap between FireFox and IE8, which is <strong>too large a gap for serious work</strong>.</p><h3>But I thought V8 / modern JS had near-C performance?</h3><p><span style="text-decoration: underline;">It depends on&nbsp;</span><strong><span style="text-decoration: underline;">what you mean by “near”</span>. &nbsp;</strong>If your C program executes in 10ms, then a 50ms JavaScript program would be “near-C” speed. &nbsp;If your C program executes in 10 seconds, a 50-second JavaScript program, for most ordinary people would probably&nbsp;<strong>not</strong> be near-C speed.</p><h2>The hardware angle</h2><p>But a factor of 5 is okay&nbsp;<strong>on x86</strong>, because x86 is ten times faster than ARM just to start with. &nbsp;You have a lot of headroom. The solution is obviously just to make ARM 10x faster, so it is competitive with x86, and then we can get desktop JS performance without doing any work!</p><p>Whether or not this works out kind of hinges on your faith in Moore’s Law in the face of trying to power a chip on a 3-ounce battery. &nbsp;I am not a hardware engineer, but I once worked for a major semiconductor company, and the people there tell me that these days performance is mostly a function of your&nbsp;<em>process</em> (e.g., the thing they measure in “nanometers”). &nbsp; The iPhone 5′s impressive performance is due in no small part to a process shrink from 45nm to 32nm — a reduction of about a third. &nbsp;But to do it again, Apple would have to shrink to a 22nm process. &nbsp;</p><p>Just for reference, Intel’s Bay Trail–the x86 Atom version of 22nm–<em>doesn’t currently exist</em>. &nbsp;And Intel had to invent a <a onclick="javascript:pageTracker._trackPageview('/outgoing/www.intel.com/content/www/us/en/energy/intel-22nm-3-d-tri-gate-transistor-technology.html');" href="http://www.intel.com/content/www/us/en/energy/intel-22nm-3-d-tri-gate-transistor-technology.html">whole new kind of transistor</a> since the ordinary kind doesn’t work at 22nm scale. &nbsp;Think they’ll license it to ARM? &nbsp;Think again. There are only a handful of 22nm fabs that people are even <em>seriously thinking about building</em> in the world, and most of them are controlled by Intel.</p><p>In fact, ARM seems on track to do a 28nm process shrink in the next year or so (watch the A7), and meanwhile Intel is on track to do 22nm and maybe even 20nm just a little further out. &nbsp;On purely a hardware level, it seems much more likely to me that an x86 chip with x86-class performance will be put in a smartphone long before an ARM chip with x86-class performance can be shrunk. &nbsp;</p><p>Update from an ex-Intel engineer who e-mailed me:</p><blockquote><p>I’m an ex-Intel engineer, worked on the mobile microprocessor line and later on the Atoms. For what it’s worth, my incredibly biased opinion is that it’s going to be easier for x86 to get into a phone envelope with the “feature toolbox” from the larger cores than it will be for ARM to grow up to x86 performance levels designing such features from scratch.</p></blockquote><p>Update from a robotics engineer who e-mailed me:</p><blockquote><p>You are perfectly right that these will not bring ultra major performance boost and that Intel may have a higher performing mobile CPU a few years from now. In fact, mobile CPUs is currently hitting the same type of limit that desktop CPUs hit when they reached ~3GHz : Increasing clock speed further is not feasible without increasing power a lot, same will be true for next process nodes although they should be able to increase IPC a bit (10-20% maybe). When they faced that limit, desktop CPUs started to become dual and quad cores, but mobile SoC are already dual and quad so there is no easy boost.</p></blockquote><p>So Moore’s Law might be right after all, but it is right in a way that would require the entire mobile ecosystem to transition to x86. It’s not entirely impossible–it’s been <a onclick="javascript:pageTracker._trackPageview('/outgoing/www.businessinsider.com/the-care-and-keeping-of-apples-super-secret-project-marklar-2012-6');" href="http://www.businessinsider.com/the-care-and-keeping-of-apples-super-secret-project-marklar-2012-6">done once before</a>. &nbsp;But it was done at a time when yearly sales were around <a onclick="javascript:pageTracker._trackPageview('/outgoing/switchtoamac.com/site/apple-reports-2006-fourth-quarter-earnings-mac-sales-rise-30-percent.html');" href="http://switchtoamac.com/site/apple-reports-2006-fourth-quarter-earnings-mac-sales-rise-30-percent.html">a million units</a>, and now they are selling 62 million <a onclick="javascript:pageTracker._trackPageview('/outgoing/techcrunch.com/2012/03/07/tim-cook-talks-ios-device-stats-315-million-sold-62-million-in-q4-alone/');" href="http://techcrunch.com/2012/03/07/tim-cook-talks-ios-device-stats-315-million-sold-62-million-in-q4-alone/">per quarter.</a>&nbsp; It was done with an off-the-shelf virtualization environment that could emulate the old architecture at about <a onclick="javascript:pageTracker._trackPageview('/outgoing/guides.macrumors.com/Rosetta_Performance_Benchmarks');" href="http://guides.macrumors.com/Rosetta_Performance_Benchmarks">60% speed</a>, meanwhile the performance of today’s hypothetical research virtualization systems for optimized (O3) ARM code are&nbsp;<a onclick="javascript:pageTracker._trackPageview('/outgoing/www.cs.princeton.edu/~thhung/pubs/odes08.pdf');" href="http://www.cs.princeton.edu/~thhung/pubs/odes08.pdf">closer to 27%</a>.</p><p>If you believe JavaScript performance is going to get there eventually, really the hardware path is the best path. &nbsp;Either Intel will have a viable iPhone chip in 5 years (likely) and Apple will switch (unlikely), or perhaps ARM will sort themselves out over the next decade. &nbsp;(Go talk to 10 hardware engineers to get 10 opinions on the viability of that.) &nbsp;But a decade is a long time, from my chair, for something that&nbsp;<em>might pan out.</em></p><p>I’m afraid my knowledge of the hardware side runs out here. What I <em>can</em> tell you is this: if you want to believe that ARM will close the gap with x86 in the next 5 years, the first step is to find somebody who works on ARM or x86 (e.g., the sort of person who would actually know) to agree with you. I have consulted many such qualified engineers for this article, and they have all declined to take the position on record. This suggests to me that the position is not any good.</p><h2>The software angle</h2><p>Here is where a lot of competent software engineers stumble. &nbsp;The thought process goes like this–JavaScript has gotten faster! &nbsp;It will continue to get faster!</p><p>The first part is true. &nbsp;JavaScript has gotten a&nbsp;<strong>lot</strong> faster. &nbsp;But we’re now at Peak JavaScript. &nbsp;It doesn’t get much faster from here.</p><p>Why? &nbsp;Well the first part is that most of the improvements to JavaScript over its history have actually been of the <strong>hardware</strong> sort. &nbsp;Jeff Atwood <a onclick="javascript:pageTracker._trackPageview('/outgoing/www.codinghorror.com/blog/2007/12/the-great-browser-javascript-showdown.html');" href="http://www.codinghorror.com/blog/2007/12/the-great-browser-javascript-showdown.html">writes</a>:</p><blockquote><p>I found that the performance of JavaScript improved a hundredfold between 1996 and 2006. If Web 2.0 is built on a backbone of JavaScript, it’s largely possible only because of those crucial Moore’s Law performance improvements.</p></blockquote><p>If we attribute JS’s speedup to hardware generally, JS’s (hardware) performance improvement <strong>does not predict future software improvement</strong>. &nbsp;This is why, if you want to believe that JS is going to get faster, by far the most likely way is by the hardware getting faster, because that is what the historical trend says.</p><p>What about JITs though? &nbsp;V8, Nitro/SFX, TraceMonkey/IonMonkey, Chakra, and the rest? &nbsp;Well, they were kind of a big deal when they came out–although not as big of a deal as you might think. &nbsp;V8 was released in September 2008. &nbsp;I dug up a copy of Firefox 3.0.3 from around the same time:</p><p><a onclick="javascript:pageTracker._trackPageview('/downloads/wp-content/uploads/2013/05/Screen-Shot-2013-05-14-at-6.41.48-PM.png');" href="http://sealedabstract.com/wp-content/uploads/2013/05/Screen-Shot-2013-05-14-at-6.41.48-PM.png"><img class="alignnone  wp-image-1719" alt="Screen Shot 2013-05-14 at 6.41.48 PM" src="http://sealedabstract.com/wp-content/uploads/2013/05/Screen-Shot-2013-05-14-at-6.41.48-PM.png" width="577" height="400"></a></p><p>Don’t get me wrong, a 9x improvement in performance is nothing to sneeze at–after all, it’s nearly the difference between ARM and x86. &nbsp;That said, the performance between Chrome 8 and Chrome 26 is a flatline, because nothing terribly important has happened since 2008. &nbsp; The other browser vendors have caught up–some slower, some faster–but nobody has really improved the speed of actual CPU code since.</p><h1>Is JavaScript improving?</h1><p><a onclick="javascript:pageTracker._trackPageview('/downloads/wp-content/uploads/2013/05/Screen-Shot-2013-05-14-at-3.59.04-AM.png');" href="http://sealedabstract.com/wp-content/uploads/2013/05/Screen-Shot-2013-05-14-at-3.59.04-AM.png"><img alt="Screen Shot 2013-05-14 at 3.59.04 AM" src="http://sealedabstract.com/wp-content/uploads/2013/05/Screen-Shot-2013-05-14-at-3.59.04-AM.png" width="667" height="471"></a></p><p>Here’s&nbsp;<a onclick="javascript:pageTracker._trackPageview('/outgoing/www.webkit.org/perf/sunspider-1.0/sunspider-1.0/results.html?%7B%22v%22:%20%22sunspider-1.0%22,%20%223d-cube%22:%5B21,15,14,19,26,15,21,36,16,14%5D,%223d-morph%22:%5B18,9,21,38,9,20,35,9,20,22%5D,%223d-raytrace%22:%5B11,8,8,8,10,11,11,11,11,12%5D,%22access-binary-trees%22:%5B2,1,1,2,1,1,2,2,1,1%5D,%22access-fannkuch%22:%5B11,11,11,11,10,11,11,10,11,12%5D,%22access-nbody%22:%5B11,33,9,10,9,10,10,10,11,10%5D,%22access-nsieve%22:%5B4,3,3,3,3,3,4,4,3,3%5D,%22bitops-3bit-bits-in-byte%22:%5B2,2,2,2,1,1,2,2,2,1%5D,%22bitops-bits-in-byte%22:%5B4,5,5,4,4,4,4,4,4,4%5D,%22bitops-bitwise-and%22:%5B7,8,7,8,7,7,8,7,8,8%5D,%22bitops-nsieve-bits%22:%5B7,8,7,7,7,9,7,8,7,7%5D,%22controlflow-recursive%22:%5B2,2,2,2,2,1,2,2,1,2%5D,%22crypto-aes%22:%5B4,5,5,6,7,8,7,7,7,6%5D,%22crypto-md5%22:%5B3,4,3,3,3,4,3,3,4,3%5D,%22crypto-sha1%22:%5B3,4,4,6,5,4,6,3,4,4%5D,%22date-format-tofte%22:%5B19,10,9,7,10,8,8,21,20,9%5D,%22date-format-xparb%22:%5B10,9,11,9,13,26,10,10,10,9%5D,%22math-cordic%22:%5B8,10,9,21,19,8,21,8,8,10%5D,%22math-partial-sums%22:%5B11,24,9,10,11,10,11,10,11,22%5D,%22math-spectral-norm%22:%5B3,3,4,3,4,4,4,4,4,4%5D,%22regexp-dna%22:%5B10,10,10,9,10,12,10,10,10,9%5D,%22string-base64%22:%5B5,4,5,28,4,5,15,5,4,5%5D,%22string-fasta%22:%5B10,32,10,10,32,10,11,12,35,29%5D,%22string-tagcloud%22:%5B19,19,32,19,20,30,18,44,18,19%5D,%22string-unpack-code%22:%5B33,24,23,25,24,23,25,25,24,23%5D,%22string-validate-input%22:%5B6,9,5,6,8,6,7,6,8,8%5D%7D');" href="http://www.webkit.org/perf/sunspider-1.0/sunspider-1.0/results.html?%7B%22v%22:%20%22sunspider-1.0%22,%20%223d-cube%22:%5B21,15,14,19,26,15,21,36,16,14%5D,%223d-morph%22:%5B18,9,21,38,9,20,35,9,20,22%5D,%223d-raytrace%22:%5B11,8,8,8,10,11,11,11,11,12%5D,%22access-binary-trees%22:%5B2,1,1,2,1,1,2,2,1,1%5D,%22access-fannkuch%22:%5B11,11,11,11,10,11,11,10,11,12%5D,%22access-nbody%22:%5B11,33,9,10,9,10,10,10,11,10%5D,%22access-nsieve%22:%5B4,3,3,3,3,3,4,4,3,3%5D,%22bitops-3bit-bits-in-byte%22:%5B2,2,2,2,1,1,2,2,2,1%5D,%22bitops-bits-in-byte%22:%5B4,5,5,4,4,4,4,4,4,4%5D,%22bitops-bitwise-and%22:%5B7,8,7,8,7,7,8,7,8,8%5D,%22bitops-nsieve-bits%22:%5B7,8,7,7,7,9,7,8,7,7%5D,%22controlflow-recursive%22:%5B2,2,2,2,2,1,2,2,1,2%5D,%22crypto-aes%22:%5B4,5,5,6,7,8,7,7,7,6%5D,%22crypto-md5%22:%5B3,4,3,3,3,4,3,3,4,3%5D,%22crypto-sha1%22:%5B3,4,4,6,5,4,6,3,4,4%5D,%22date-format-tofte%22:%5B19,10,9,7,10,8,8,21,20,9%5D,%22date-format-xparb%22:%5B10,9,11,9,13,26,10,10,10,9%5D,%22math-cordic%22:%5B8,10,9,21,19,8,21,8,8,10%5D,%22math-partial-sums%22:%5B11,24,9,10,11,10,11,10,11,22%5D,%22math-spectral-norm%22:%5B3,3,4,3,4,4,4,4,4,4%5D,%22regexp-dna%22:%5B10,10,10,9,10,12,10,10,10,9%5D,%22string-base64%22:%5B5,4,5,28,4,5,15,5,4,5%5D,%22string-fasta%22:%5B10,32,10,10,32,10,11,12,35,29%5D,%22string-tagcloud%22:%5B19,19,32,19,20,30,18,44,18,19%5D,%22string-unpack-code%22:%5B33,24,23,25,24,23,25,25,24,23%5D,%22string-validate-input%22:%5B6,9,5,6,8,6,7,6,8,8%5D%7D">Chrome v8</a>&nbsp;on my Mac (the earliest one that still ran, Dec 2010.) &nbsp;Now here’s<a onclick="javascript:pageTracker._trackPageview('/outgoing/www.webkit.org/perf/sunspider-1.0/sunspider-1.0/results.html?%7B%22v%22:%20%22sunspider-1.0%22,%20%223d-cube%22:%5B11,8,47,7,19,12,19,13,16,8%5D,%223d-morph%22:%5B7,7,8,7,43,7,41,14,7,7%5D,%223d-raytrace%22:%5B9,14,10,10,9,10,9,14,9,12%5D,%22access-binary-trees%22:%5B2,5,1,2,2,2,2,4,2,2%5D,%22access-fannkuch%22:%5B12,12,12,12,12,12,12,8,13,13%5D,%22access-nbody%22:%5B10,42,7,4,4,22,6,6,21,7%5D,%22access-nsieve%22:%5B2,2,2,8,2,3,2,2,33,4%5D,%22bitops-3bit-bits-in-byte%22:%5B2,2,1,2,1,1,1,1,1,1%5D,%22bitops-bits-in-byte%22:%5B5,4,5,4,4,4,4,4,4,4%5D,%22bitops-bitwise-and%22:%5B3,4,4,3,3,4,4,3,4,4%5D,%22bitops-nsieve-bits%22:%5B6,6,6,41,6,6,5,6,6,6%5D,%22controlflow-recursive%22:%5B2,2,3,2,3,2,3,2,3,3%5D,%22crypto-aes%22:%5B13,6,9,5,5,6,6,7,7,8%5D,%22crypto-md5%22:%5B6,8,5,5,4,5,5,5,6,5%5D,%22crypto-sha1%22:%5B10,5,5,5,6,6,5,6,6,6%5D,%22date-format-tofte%22:%5B47,9,9,9,11,8,8,8,9,10%5D,%22date-format-xparb%22:%5B10,10,9,12,15,14,14,10,14,11%5D,%22math-cordic%22:%5B3,3,4,3,4,4,3,3,3,7%5D,%22math-partial-sums%22:%5B11,13,9,8,17,12,18,9,12,11%5D,%22math-spectral-norm%22:%5B2,3,3,5,6,3,7,2,3,2%5D,%22regexp-dna%22:%5B8,8,12,8,40,7,31,9,7,13%5D,%22string-base64%22:%5B4,4,10,4,5,5,6,5,5,10%5D,%22string-fasta%22:%5B10,10,46,10,11,10,9,11,11,38%5D,%22string-tagcloud%22:%5B25,24,23,27,23,23,22,24,27,26%5D,%22string-unpack-code%22:%5B23,40,24,23,29,22,28,32,37,22%5D,%22string-validate-input%22:%5B14,12,14,7,7,18,8,7,37,14%5D%7D');" href="http://www.webkit.org/perf/sunspider-1.0/sunspider-1.0/results.html?%7B%22v%22:%20%22sunspider-1.0%22,%20%223d-cube%22:%5B11,8,47,7,19,12,19,13,16,8%5D,%223d-morph%22:%5B7,7,8,7,43,7,41,14,7,7%5D,%223d-raytrace%22:%5B9,14,10,10,9,10,9,14,9,12%5D,%22access-binary-trees%22:%5B2,5,1,2,2,2,2,4,2,2%5D,%22access-fannkuch%22:%5B12,12,12,12,12,12,12,8,13,13%5D,%22access-nbody%22:%5B10,42,7,4,4,22,6,6,21,7%5D,%22access-nsieve%22:%5B2,2,2,8,2,3,2,2,33,4%5D,%22bitops-3bit-bits-in-byte%22:%5B2,2,1,2,1,1,1,1,1,1%5D,%22bitops-bits-in-byte%22:%5B5,4,5,4,4,4,4,4,4,4%5D,%22bitops-bitwise-and%22:%5B3,4,4,3,3,4,4,3,4,4%5D,%22bitops-nsieve-bits%22:%5B6,6,6,41,6,6,5,6,6,6%5D,%22controlflow-recursive%22:%5B2,2,3,2,3,2,3,2,3,3%5D,%22crypto-aes%22:%5B13,6,9,5,5,6,6,7,7,8%5D,%22crypto-md5%22:%5B6,8,5,5,4,5,5,5,6,5%5D,%22crypto-sha1%22:%5B10,5,5,5,6,6,5,6,6,6%5D,%22date-format-tofte%22:%5B47,9,9,9,11,8,8,8,9,10%5D,%22date-format-xparb%22:%5B10,10,9,12,15,14,14,10,14,11%5D,%22math-cordic%22:%5B3,3,4,3,4,4,3,3,3,7%5D,%22math-partial-sums%22:%5B11,13,9,8,17,12,18,9,12,11%5D,%22math-spectral-norm%22:%5B2,3,3,5,6,3,7,2,3,2%5D,%22regexp-dna%22:%5B8,8,12,8,40,7,31,9,7,13%5D,%22string-base64%22:%5B4,4,10,4,5,5,6,5,5,10%5D,%22string-fasta%22:%5B10,10,46,10,11,10,9,11,11,38%5D,%22string-tagcloud%22:%5B25,24,23,27,23,23,22,24,27,26%5D,%22string-unpack-code%22:%5B23,40,24,23,29,22,28,32,37,22%5D,%22string-validate-input%22:%5B14,12,14,7,7,18,8,7,37,14%5D%7D">&nbsp;v26</a>. &nbsp;</p><p>Can’t spot the difference? &nbsp;That’s because there isn’t one. &nbsp;<strong>Nothing terribly important has happened to CPU-bound JavaScript lately.</strong></p><p>If the web feels faster to you than it did in 2010, that is probably because you’re running a faster computer, but it has nothing to do with improvements to Chrome.</p><p><strong>Update</strong> Some smart people have pointed out that SunSpider isn’t a good benchmark these days (but have declined to provide any actual numbers or anything). In the interests of having a reasonable conversation, I ran Octane (a Google benchmark) on some old versions of Chrome, and it does show some improvement:</p><p><a onclick="javascript:pageTracker._trackPageview('/downloads/wp-content/uploads/2013/07/Screen-Shot-2013-07-09-at-3.59.43-PM.png');" href="http://sealedabstract.com/wp-content/uploads/2013/07/Screen-Shot-2013-07-09-at-3.59.43-PM.png"><img src="http://sealedabstract.com/wp-content/uploads/2013/07/Screen-Shot-2013-07-09-at-3.59.43-PM.png" alt="Octane on V8, 2011 to 2013" width="700" class="alignnone size-full wp-image-1928"></a></p><p>In my opinion, this magnitude of performance gain over this period is much too small to support the claim that JS will close the gap in any reasonable amount of time. However, I think it’s fair to say that I overstated the case a bit–<em>something</em> is happening in CPU-bound JavaScript. But to me, these numbers confirm the larger hypothesis: these gains are not the order-of-magnitude that will close the gap with native code, in any reasonable amount of time. You need to get to 2x-9x across the board to compete with LLVM. These improvements are good, but they’re not that good. <strong>End update</strong></p><p>The thing is, JITing JavaScript was a 60-year old idea with 60 years of research, and literally thousands of implementations for every conceivable programming language demonstrating that it was a good idea. &nbsp;But now that we’ve done it, we’ve run out of 60-year-old ideas. &nbsp;That’s all, folks. &nbsp;Show’s over. &nbsp;Maybe we can grow another good idea in the next 60 years.</p><h1>But Safari is supposedly faster than before?</h1><p>But if this is all true, how come we keep hearing about all the great performance improvements in JavaScript? It seems every other week, somebody is touting huge speedups in some benchmark. Here is Apple claiming a staggering 3.8x speedup on JSBench:</p><div id="attachment_1913" class="wp-caption alignnone size-full wp-image-1913" style="width:465px"><img src="http://sealedabstract.com/wp-content/uploads/2013/07/Screen-Shot-2013-07-08-at-11.45.38-PM.png" alt="Is Safari 7 3.8x faster than the other guys?" width="465" height="324" class="size-full wp-image-1913"><p class="wp-caption-text">]<a onclick="javascript:pageTracker._trackPageview('/downloads/wp-content/uploads/2013/07/Screen-Shot-2013-07-08-at-11.45.38-PM.png');" href="http://sealedabstract.com/wp-content/uploads/2013/07/Screen-Shot-2013-07-08-at-11.45.38-PM.png">56</a> Is Safari 7 3.8x faster than the other guys?</p></div><p>Perhaps conveniently for Apple, this version of Safari is currently under NDA, so nobody is able to publish independent numbers on Safari performance one way or the other. But let me make some observations on this kind of claim that’s purely on the basis of publicly available information.</p><p>I find it interesting, first, that Apple’s public claims on JSBench are much higher than their claims for traditional benchmarks like SunSpider. Now JSBench <a onclick="javascript:pageTracker._trackPageview('/outgoing/sss.cs.purdue.edu/projects/dynjs/jsbench-oopsla-2011.pdf');" href="http://sss.cs.purdue.edu/projects/dynjs/jsbench-oopsla-2011.pdf">has some cool names behind it</a> including Brenden Eich, the creator of JavaScript. But unlike traditional benchmarks, the way JSBench works isn’t by writing a program that factors integers or something. Instead, JSBench automatically scrapes whatever Amazon, Facebook, and Twitter serve up, and builds benchmarks out of that. If you are writing a web browser that (let’s be honest) most people use to browse Facebook, I can see how having a benchmark that’s literally Facebook is very useful. On the other hand, if you are writing a spreadsheet program, or a game, or an image filter application, it seems to me that a traditional benchmark with e.g. integer arithmetic and md5 hashing is going to be much more predictive for you than seeing how fast Facebook’s analytics code can run.</p><p>The other important fact is that an improvement on SunSpider, as Apple claims, does not necessarily mean anything else improves. In the very paper that introduces Apple’s preferred benchmark, Eich et al write the following:</p><blockquote><p>The graph clearly shows that, according to SunSpider, the performance of Firefox improved over 13× between version 1.5 and version 3.6. Yet when we look at the performance improvements on amazon they are a more modest 3×. And even more interestingly, in the last two years, gains on amazon have flattened. Suggesting that some of the optimizations that work well on Sun Spider do little for amazon. [sic]</p></blockquote><p><em>In this very paper</em>, the creator of JavaScript and one of the top architects for Mozilla openly admits that nothing at all has happened to the performance of Amazon’s JavaScript in two years, and nothing terribly exciting has <em>ever</em> happened. This is your clue that the marketing guys have oversold things just a bit over the years.</p><p>(They go on to argue, essentially, that benchmarking Amazon is a better predictor for running Amazon than benchmarking SunSpider [uh... obvious...], and is therefore good to do for web browsers which people use to visit Amazon. But none of this will help you write a photo processing application.)</p><p>But at any rate, what I can tell you, from publicly available information, is that Apple’s claims of 3.8x faster whatever does not necessarily translate into anything useful to you. I can also tell you that if I had benchmarks that refuted Apple’s claims of beating Chrome, I would not be allowed to publish them.</p><p>So let’s just conclude this section by saying that just because somebody has a bar chart that shows their web browser is faster does not necessarily mean JS as a whole is getting any faster.</p><p>But there is a bigger problem.</p><h2>Not designed for performance</h2><p><a onclick="javascript:pageTracker._trackPageview('/downloads/wp-content/uploads/2013/05/JavaScript-the-good-parts.jpg');" href="http://sealedabstract.com/wp-content/uploads/2013/05/JavaScript-the-good-parts.jpg"><img class="alignnone size-full wp-image-1741" alt="JavaScript-the-good-parts" src="http://sealedabstract.com/wp-content/uploads/2013/05/JavaScript-the-good-parts.jpg" width="600" height="450"></a></p><p>This is from <a onclick="javascript:pageTracker._trackPageview('/outgoing/herbsutter.com/2012/04/02/reader-qa-when-will-better-jits-save-managed-code/');" href="http://herbsutter.com/2012/04/02/reader-qa-when-will-better-jits-save-managed-code/">Herb Sutter</a>, one of the big names in modern C++:</p><blockquote><p>This is a 199x/200x meme that’s hard to kill – “just wait for the next generation of (JIT or static) compilers and then managed languages will be as efficient.” Yes, I fully expect C# and Java compilers to keep improving – both JIT and NGEN-like static compilers. But no, they won’t erase the efficiency difference with native code, for two reasons. First, JIT compilation isn’t the main issue. The root cause is much more fundamental: <strong>Managed languages made deliberate design tradeoffs to optimize for programmer productivity even when that was fundamentally in tension with, and at the expense of, performance efficiency</strong>… In particular, managed languages chose to incur costs even for programs that don’t need or use a given feature; the major examples are assumption/reliance on always-on or default-on garbage collection, a virtual machine runtime, and metadata. But there are other examples; for instance, managed apps are built around virtual functions as the default, whereas C++ apps are built around inlined functions as the default, and an ounce of inlining prevention is worth a pound of devirtualization optimization cure.</p></blockquote><p>This quote was <a onclick="javascript:pageTracker._trackPageview('/outgoing/tirania.org/blog/archive/2012/Apr-04.html');" href="http://tirania.org/blog/archive/2012/Apr-04.html">endorsed</a> by Miguel de Icaza of Mono, who is on the very short list of “people who maintain a major JIT compiler”. &nbsp;He said:</p><blockquote><p>This is a pretty accurate statement on the difference of the mainstream VMs for managed languages (.NET, Java and Javascript). Designers of managed languages have chosen the path of safety over performance for their designs.</p></blockquote><p>Or, you could talk to <a onclick="javascript:pageTracker._trackPageview('/outgoing/vimeo.com/61044810');" href="http://vimeo.com/61044810">Alex Gaynor</a>, who maintains an optimizing JIT for Ruby and contributes to the optimizing JIT for Python:</p><blockquote><p>It’s the curse of these really high-productivity dynamic languages. &nbsp;They make creating hash tables incredibly easy. &nbsp;And that’s an incredibly good thing, because I think C programmers probably underuse hash tables, because they’re a pain. &nbsp;For one you don’t have one built in. &nbsp;For two, when you try to use one, you just hit pain left and right. &nbsp;By contrast, Python, Ruby, JavaScript people, we overuse hashtables because they’re so easy… And as a result, people don’t care…</p></blockquote><p><a onclick="javascript:pageTracker._trackPageview('/outgoing/gist.github.com/paulmillr/1208618');" href="https://gist.github.com/paulmillr/1208618">Google</a> seems to think that JavaScript is facing a performance wall:</p><blockquote><p>Complex web apps–the kind that Google&nbsp;specializes in–are struggling against the platform and working with a&nbsp;language that cannot be tooled and has inherent performance problems.</p></blockquote><p>Lastly, hear it from the horse’s mouth. &nbsp;One of <a onclick="javascript:pageTracker._trackPageview('/outgoing/catwell.info');" href="http://catwell.info">my readers</a> pointed me to <a onclick="javascript:pageTracker._trackPageview('/outgoing/lambda-the-ultimate.org/node/3851#comment-57671');" href="http://lambda-the-ultimate.org/node/3851#comment-57671">this comment </a>by Brendan Eich. &nbsp;You know, the guy who invented JavaScript.</p><blockquote><p>One thing Mike didn’t highlight: <strong>get a simpler language</strong>. Lua is much simpler than JS. This means you can make a simple interpreter that runs fast enough to be balanced with respect to the trace-JITted code [unlike with JS].</p></blockquote><p>and a little further down:</p><blockquote><p>On the differences between JS and Lua, you can say it’s all a matter of proper design and engineering (what isn’t?), but intrinsic complexity differences in degree still cost. You can push the hard cases off the hot paths, certainly, but they take their toll. <strong>JS has more and harder hard cases than Lua.</strong> One example: Lua (without explicit metatable usage) has nothing like JS’s prototype object chain.</p></blockquote><p>Of the people who actually do relevant work: the view that JS in particular, or dynamic languages in general, will catch up with C, is <em>very much the minority view</em>. &nbsp;There are a few stragglers here and there, and there is also no real consensus what to do about it, or if anything should be done about it at all. &nbsp;But as to the question of whether, from a language perspective, in general, the JITs will catch up–the answer from the people working on them is “no, not without changing either the language or the APIs.”</p><p>But there is an even bigger problem.</p><h2>All about garbage collectors</h2><p><a onclick="javascript:pageTracker._trackPageview('/downloads/wp-content/uploads/2013/05/highest-paying-dirty-job-1.jpg');" href="http://sealedabstract.com/wp-content/uploads/2013/05/highest-paying-dirty-job-1.jpg"><img class="alignnone size-full wp-image-1742" alt="highest-paying-dirty-job-1" src="http://sealedabstract.com/wp-content/uploads/2013/05/highest-paying-dirty-job-1.jpg" width="400" height="266"></a></p><p>You see, the CPU problem, and all the CPU-bound benchmarks, and all the CPU-bound design decisions–that’s really only half the story. &nbsp;The other half is memory. &nbsp;And it turns out, the memory problem is so vast, that the whole CPU question is just the tip of the iceberg. In fact, arguably, that entire CPU discussion is a red herring. &nbsp;<strong>What you are about to read should change the whole way you think about mobile software development</strong>.</p><p>In 2012, Apple did a curious thing (well, unless you are John Gruber and <a onclick="javascript:pageTracker._trackPageview('/outgoing/daringfireball.net/linked/2011/09/19/the-unfamiliar');" href="http://daringfireball.net/linked/2011/09/19/the-unfamiliar">saw it coming</a>). &nbsp;They pulled garbage collection out of OSX. &nbsp;Seriously, go <a onclick="javascript:pageTracker._trackPageview('/outgoing/developer.apple.com/legacy/library/documentation/Cocoa/Conceptual/GarbageCollection/GarbageCollection.pdf');" href="https://developer.apple.com/legacy/library/documentation/Cocoa/Conceptual/GarbageCollection/GarbageCollection.pdf">read the programming guide</a>. &nbsp;It has a big fat “(Not Recommended)” right in the title. If you come from Ruby, or Python, or JavaScript, or Java, or C#, or really any language since the 1990s, this should strike you as&nbsp;<strong>really odd</strong>. &nbsp;But it probably doesn’t affect you, because you probably don’t write ObjC for Mac, so meh, click the next link on HN. &nbsp;But still, it seems <em>strange</em>. &nbsp;After all, GC has been around, it’s been <strong>proven</strong>. &nbsp;Why in the world would you <em>deprecate</em> it? &nbsp;Here’s what Apple had to say:</p><blockquote><p>We feel so strongly about ARC being the right approach to memory management that we have decided to deprecate Garbage Collection in OSX. &nbsp;- Session 101, Platforms Kickoff, 2012, ~01:13:50</p></blockquote><p>The part that the transcript doesn’t tell you is that <strong>the audience broke out into applause upon hearing this statement</strong>. Okay, now this is&nbsp;<strong>really freaking weird</strong>. &nbsp;You mean to tell me that there’s a room full of developers <strong>applauding the return</strong> to the pre-garbage collection chaos? &nbsp;Just <em>imagine</em> the pin drop if Matz announced the deprecation of GC at RubyConf. &nbsp;And these guys are <strong>happy</strong> about it? &nbsp;Weirdos.</p><p>Rather than write off the Apple fanboys as a cult, this&nbsp;<em>very odd</em> reaction should clue you in&nbsp;<strong>that there is more going on here than meets the eye</strong>. &nbsp;And this “more going on” bit is the subject of our next line of inquiry.</p><p>So the thought process goes like this: &nbsp;<strong>Pulling a working garbage collector out of a language is totally crazy, amirite?</strong>&nbsp; One simple explanation is that perhaps ARC is just a special Apple marketing term for a fancypants kind of garbage collector, and so what these developers are, in fact applauding–is an&nbsp;<em>upgrade</em> rather than a <em>downgrade</em>. &nbsp;In fact, this is a belief that a lot of iOS noobs have.</p><h3>ARC is not a garbage collector</h3><p>So to all the people who think ARC is some kind of garbage collector, I just want to beat your face in with the following Apple slide:</p><p><a onclick="javascript:pageTracker._trackPageview('/downloads/wp-content/uploads/2013/05/Screen-Shot-2013-05-14-at-9.44.43-PM.png');" href="http://sealedabstract.com/wp-content/uploads/2013/05/Screen-Shot-2013-05-14-at-9.44.43-PM.png"><img class="alignnone  wp-image-1720" alt="Screen Shot 2013-05-14 at 9.44.43 PM" src="http://sealedabstract.com/wp-content/uploads/2013/05/Screen-Shot-2013-05-14-at-9.44.43-PM.png" width="685" height="431"></a></p><p>This has nothing to do with the <a onclick="javascript:pageTracker._trackPageview('/outgoing/en.wikipedia.org/wiki/Reference_counting#Use_in_garbage_collection');" href="http://en.wikipedia.org/wiki/Reference_counting#Use_in_garbage_collection">similarly-named garbage collection algorithm</a>. &nbsp;It isn’t GC, it isn’t anything like GC, it performs nothing like GC, it does not have the power of GC, it does not break retain cycles, it does not sweep anything, it does not scan anything. &nbsp;Period, end of story, not garbage collection.</p><p>The myth somehow grew legs when a lot of the documentation was under NDA (but the <a onclick="javascript:pageTracker._trackPageview('/outgoing/clang.llvm.org/docs/AutomaticReferenceCounting.html');" href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html">spec was available</a>, so that’s no excuse) and as a result the blogosphere <a onclick="javascript:pageTracker._trackPageview('/outgoing/www.google.com/search?client=safari&amp;rls=en&amp;q=ios+5+garbage+collection&amp;ie=UTF-8&amp;oe=UTF-8#client=safari&amp;rls=en&amp;sclient=psy-ab&amp;q=%22ios+5%22+%22garbage+collection%22&amp;oq=%22ios+5%22+%22garbage+collection%22&amp;gs_l=serp.3..0i30j0i7i30l2j0i7i5i10i30.4068.5462.5.6004.2.2.0.0.0.0.222.309.1j0j1.2.0...0.0...1c.1.12.psy-ab.54dZ4wfYjzs&amp;pbx=1&amp;bav=on.2,or.r_cp.r_qf.&amp;bvm=bv.46471029,d.eWU&amp;fp=7bc92cb06490597b&amp;biw=1920&amp;bih=960');" href="https://www.google.com/search?client=safari&amp;rls=en&amp;q=ios+5+garbage+collection&amp;ie=UTF-8&amp;oe=UTF-8#client=safari&amp;rls=en&amp;sclient=psy-ab&amp;q=%22ios+5%22+%22garbage+collection%22&amp;oq=%22ios+5%22+%22garbage+collection%22&amp;gs_l=serp.3..0i30j0i7i30l2j0i7i5i10i30.4068.5462.5.6004.2.2.0.0.0.0.222.309.1j0j1.2.0...0.0...1c.1.12.psy-ab.54dZ4wfYjzs&amp;pbx=1&amp;bav=on.2,or.r_cp.r_qf.&amp;bvm=bv.46471029,d.eWU&amp;fp=7bc92cb06490597b&amp;biw=1920&amp;bih=960">has widely reported it to be true</a>. &nbsp;It’s not. &nbsp;Just stop.</p><h3>GC is not as feasible as your experience leads you to believe</h3><p>So here’s what Apple has to say about ARC vs GC, when pressed:</p><blockquote><p>At the top of your wishlist of things we could do for you is bringing garbage collection to iOS. And that is exactly what we are not going to do… Unfortunately garbage collection has a suboptimal impact on performance. Garbage can build up in your applications and increase the high water mark of your memory usage. And the collector tends to kick in at undeterministic times which can lead to very high CPU usage and stutters in the user experience. And that’s why GC has not been acceptable to us on our mobile platforms. In comparison, manual memory management with retain/release is harder to learn, and quite frankly it’s a bit of a pain in the ass. But it produces better and more predictable performance, and that’s why we have chosen it as the basis of our memory management strategy. Because out there in the real world, high performance and stutter-free user experiences are what matters to our users. ~Session 300, Developer Tools Kickoff, 2011, 00:47:49</p></blockquote><p>But that’s totally crazy, amirite? &nbsp;Just for starters:</p><ol><li><span style="line-height: 13px;">It probably flies in the face of your entire career of experiencing the performance impact of GCed languages on the desktop and server</span></li><li>Windows Mobile, Android, MonoTouch, and the whole rest of them seem to be getting along fine with GC</li></ol><p>So let’s take them in turn.</p><h3>GC on mobile is not the same animal as GC on the desktop</h3><p>I know what you’re thinking. &nbsp;You’ve been a Python developer for N years. &nbsp;It’s 2013. &nbsp;Garbage collection is a totally solved problem.</p><p><a onclick="javascript:pageTracker._trackPageview('/outgoing/www-cs.canisius.edu/~hertzm/gcmalloc-oopsla-2005.pdf');" href="http://www-cs.canisius.edu/~hertzm/gcmalloc-oopsla-2005.pdf">Here is the paper</a> you were looking for. &nbsp;<strong>Turns out it’s not so solved</strong>: <a onclick="javascript:pageTracker._trackPageview('/downloads/wp-content/uploads/2013/05/Screen-Shot-2013-05-14-at-10.15.29-PM.png');" href="http://sealedabstract.com/wp-content/uploads/2013/05/Screen-Shot-2013-05-14-at-10.15.29-PM.png"><img class="alignnone size-full wp-image-1721" alt="Screen Shot 2013-05-14 at 10.15.29 PM" src="http://sealedabstract.com/wp-content/uploads/2013/05/Screen-Shot-2013-05-14-at-10.15.29-PM.png" width="652" height="483"></a></p><p><strong>If you remember nothing else from this blog post,</strong> <em><span style="text-decoration: underline;"><strong>remember this chart</strong></span></em>. &nbsp;The Y axis is time spent collecting garbage. &nbsp;The X axis is “relative memory footprint”. &nbsp;Relative to what? &nbsp;Relative to the <strong>minimum amount of memory required</strong>.</p><p>What this chart says is “As long as you have about 6 times as much memory as you really need, you’re fine. &nbsp;<strong>But woe betide you if you have less than 4x the required memory</strong>.” But don’t take my word for it:</p><blockquote><p>In particular, when garbage collection has five times as much memory as required, its runtime performance matches or slightly exceeds that of explicit memory management. However, garbage collection’s performance degrades substantially when it must use smaller heaps. With three times as much memory, it runs 17% slower on average, and with twice as much memory, it runs 70% slower. Garbage collection also is more susceptible to paging when physical memory is scarce. In such conditions, all of the garbage collectors we examine here <strong>suffer order-of-magnitude performance penalties relative to explicit memory management</strong>.</p></blockquote><p>Now let’s compare with explicit memory management strategies:</p><blockquote><p>These graphs show that, for reasonable ranges of available memory (but not enough to hold the entire application), <strong>both explicit memory managers substantially outperform all of the garbage collectors</strong>. For instance, pseudoJBB running with 63MB of available memory and the Lea allocator completes in 25 seconds. With the same amount of available memory and using GenMS, it takes <strong>more than ten times longer to complete</strong> (255 seconds). We see similar trends across the benchmark suite. The most pronounced case is 213 javac: at 36MB with the Lea allocator, total execution time is 14 seconds, while with GenMS, total execution time is 211 seconds, over a 15-fold increase.</p></blockquote><p>The ground truth is that&nbsp;<span style="text-decoration: underline;">in a memory constrained environment</span><strong>&nbsp;</strong>garbage collection performance degrades exponentially. &nbsp;If you write Python or Ruby or JS that runs on desktop computers, it’s possible that <strong>your entire experience is in the right hand of the chart</strong>, and you can go your whole life without ever experiencing a slow garbage collector. &nbsp;Spend some time on the left side of the chart and see what the rest of us deal with.</p><h3>How much memory is available on iOS?</h3><p>It’s hard to say exactly. &nbsp;The physical memory on the devices vary pretty considerably–from 512MB on the iPhone 4 up to 1GB on the iPhone 5. &nbsp;But a lot of that is reserved for the system, and still more of it is reserved for multitasking. &nbsp;Really the only way to find out is to try it under various conditions. &nbsp;Jan Ilavsky <a onclick="javascript:pageTracker._trackPageview('/outgoing/github.com/split82/iOSMemoryBudgetTest');" href="https://github.com/split82/iOSMemoryBudgetTest">helpfully wrote a utility</a> to do it, but it seems that nobody publishes any statistics. &nbsp;That changes today.</p><p>Now it’s important to do this under “normal” conditions (whatever that means), because if you do it from a fresh boot or back-to-back, you will get better results since you don’t have pages open in Safari and such. &nbsp;So I literally grabbed devices under the “real world” condition of lying around my apartment somewhere to run this benchmark.</p><p><a onclick="javascript:pageTracker._trackPageview('/downloads/wp-content/uploads/2013/05/Photo-May-14-10-53-53-PM.png');" href="http://sealedabstract.com/wp-content/uploads/2013/05/Photo-May-14-10-53-53-PM.png"><img class="alignnone size-medium wp-image-1723" alt="Photo May 14, 10 53 53 PM" src="http://sealedabstract.com/wp-content/uploads/2013/05/Photo-May-14-10-53-53-PM-200x300.png" width="200" height="300"></a><a onclick="javascript:pageTracker._trackPageview('/downloads/wp-content/uploads/2013/05/Photo-May-14-10-51-13-PM.png');" href="http://sealedabstract.com/wp-content/uploads/2013/05/Photo-May-14-10-51-13-PM.png"><img class="alignnone size-medium wp-image-1722" alt="Photo May 14, 10 51 13 PM" src="http://sealedabstract.com/wp-content/uploads/2013/05/Photo-May-14-10-51-13-PM-225x300.png" width="225" height="300"></a></p><p>You can click through to see the detailed results but essentially on the iPhone 4S, you start getting warned around 40MB and you get killed around 213MB. &nbsp;On the iPad 3, you get warned around 400MB and you get killed around 550MB. &nbsp;Of course, these are just my numbers–if your users are listening to music or running things in the background, you may have considerably less memory than you do in my results, but this is a start. This seems like a lot (213mb should be enough for everyone, right?) but as a practical matter it isn’t. &nbsp;For example, the iPhone 4S snaps photos at 3264×2448 resolution. &nbsp;&nbsp;That’s over 30 megabytes of bitmap data per photo. &nbsp;That’s a warning for having <strong>just two photos in memory</strong> and you get killed for having&nbsp;<strong>7 photos in RAM</strong>. &nbsp;Oh, you were going to write a for loop that iterated over an album? &nbsp;Killed.</p><p>It’s important to emphasize too that as a practical matter you often have the same photo in memory multiple places. &nbsp;For example, if you are taking a photo, you have 1) The camera screen that shows you what the camera sees, 2) the photo that the camera actually took, 3) the buffer that you’re trying to fill with compressed JPEG data to write to disk, 4) the version of the photo that you’re preparing for display in the next screen, and 5) the version of the photo that you’re uploading to some server. &nbsp;</p><p>At some point it will occur to you that keeping 30MB buffers open to display a photo thumbnail is a really bad idea, so you will introduce 6) the buffer that is going to hold a smaller photo suitable for display in the next screen, 7) the buffer that resizes the photo in the background because it is too slow to do it in the foreground. &nbsp;And then you will discover that you really need five different sizes, and thus begins the slow descent into madness. &nbsp;It’s not uncommon to hit memory limits dealing just with a <strong>single photograph</strong> in a real-world application. But don’t take my word for it:</p><blockquote><p>The worst thing that you can do as far as your memory footprint is to cache images in memory. &nbsp;When an image is drawn into a bitmap context or displayed to a screen, we actually have to decode that image into a bitmap. &nbsp;That bitmap is 4 bytes per pixel, no matter how big the original image was. &nbsp;And as soon as we’ve decoded it once, that bitmap is attached to the image object, and will then persist for the lifetime of the object. &nbsp;So if you’re putting images into a cache, and they ever get displayed, you’re now holding onto that entire bitmap until you release it. &nbsp;So never put UIImages or CGImages into a cache, unless you have a very clear (and hopefully very short-term) reason for doing so. &nbsp;- Session 318, iOS Performance In Depth, 2011</p></blockquote><p>Don’t even take his word for it! &nbsp;The amount of memory you allocate yourself is just the tip of the iceberg. &nbsp;No honest, here’s the actual iceberg slide from Apple. &nbsp;Session 242, iOS App Performance – Memory, 2012:</p><p><a onclick="javascript:pageTracker._trackPageview('/downloads/wp-content/uploads/2013/05/Screen-Shot-2013-05-15-at-5.39.12-AM.png');" href="http://sealedabstract.com/wp-content/uploads/2013/05/Screen-Shot-2013-05-15-at-5.39.12-AM.png"><img class="alignnone size-medium wp-image-1733" alt="Screen Shot 2013-05-15 at 5.39.12 AM" src="http://sealedabstract.com/wp-content/uploads/2013/05/Screen-Shot-2013-05-15-at-5.39.12-AM-300x187.png" width="300" height="187"></a></p><p>And you’re burning the candle from both ends. &nbsp;Not only is it much harder to deal with photos if you have 213MB of usable RAM than it is on a desktop. &nbsp;But there is also a lot more demand to write photo-processing applications, <strong>because your desktop does not have a great camera attached to it that fits in your pocket</strong>.</p><p>Let’s take another example. &nbsp;On the iPad 3, you are driving a display that probably has more pixels in it than the display on your desktop (it’s between 2K and 4K resolution, in the ballpark with pro cinema). &nbsp;Each frame that you show on that display is a 12MB bitmap. &nbsp;If you’re going to be a good memory citizen you can store roughly 45 frames of uncompressed video or animation buffer in memory at a time, which is about 1.5 seconds at 30fps, or .75 seconds at the system’s 60Hz. &nbsp;Accidentally buffer a second of full-screen animation? &nbsp;App killed. &nbsp;And it’s worth pointing out, <a onclick="javascript:pageTracker._trackPageview('/outgoing/stackoverflow.com/questions/9997882/detecting-the-airplay-latency');" href="http://stackoverflow.com/questions/9997882/detecting-the-airplay-latency">the latency of AirPlay is 2 seconds</a>, so for any kind of media application, you are actually&nbsp;<strong>guaranteed to not have enough memory</strong>.</p><p>And we are in roughly the same situation here that we are in with the multiple copies of the photos. &nbsp;For example, <a onclick="javascript:pageTracker._trackPageview('/outgoing/developer.apple.com/library/ios/#qa/qa1708/_index.html');" href="http://developer.apple.com/library/ios/#qa/qa1708/_index.html">Apple says</a> that “Every UIView is backed with a CALayer and images as layer contents remain in memory as long as the CALayer stays in the hierarchy.” &nbsp;What this means, essentially, is that there can be many intermediate renderings–essentially copies–of your view hierarchy that are stored in memory. &nbsp;</p><p>And there are also things like clipping rects, and backing stores. &nbsp;It’s a remarkably efficient architecture as far as CPU time goes, but it achieves that performance essentially at the cost of gobbling as much memory as possible. &nbsp;iOS is <em>not architected to be low-memory–it’s optimized to be fast</em>. Which just doesn’t mix with garbage collection.</p><p>We are also in the same situation about burning the candle from both ends. &nbsp;Not only are you in an incredibly memory-constrained environment for doing animations. &nbsp;But there is also a huge demand to do super high-quality video and animation, because this awful, memory-constrained environment is literally the only form factor in which a consumer-class pro-cinema-resolution display can be purchased. If you want to write software that runs on a comparable display, you have to convince somebody to shell out <a onclick="javascript:pageTracker._trackPageview('/outgoing/www.cdw.com/shop/products/HP-ZR2740w-LED-monitor-27in-Smart-Buy/2501971.aspx');" href="http://www.cdw.com/shop/products/HP-ZR2740w-LED-monitor-27in-Smart-Buy/2501971.aspx">$700</a> just for the monitor. Or, they could spend $500, and get an iPad, with the computer already built in.</p><h3>Will we get more memory? (UPDATE)</h3><p>Some smart people have said “OK, you talk a lot about how we won’t get faster CPUs. But we can get more memory, right? It happened on desktop.”</p><p>One problem with this theory is that with ARM the memory <strong>is on the processor itself</strong>. It’s called <a onclick="javascript:pageTracker._trackPageview('/outgoing/en.wikipedia.org/wiki/Package_on_package');" href="http://en.wikipedia.org/wiki/Package_on_package">package on package</a>. So the problems with getting more memory on ARM are actually <em>very analogous</em> to the problems of improving the CPU, because at the end of the day it boils down to the same thing: packing more transistors on the CPU package. Memory transistors are a little easier to work with, because they are uniform, so it’s not quite as hard. But it’s still hard.</p><p>If you look at iFixit’s <a onclick="javascript:pageTracker._trackPageview('/outgoing/www.ifixit.com/Teardown/Apple+A6+Teardown/10528/2');" href="http://www.ifixit.com/Teardown/Apple+A6+Teardown/10528/2">picture of the A6</a>, you see that at the moment almost 100% of the top silicon on the CPU die is memory. What this means is that <strong>to have more memory, you need either a process shrink or a bigger die</strong>. In fact, if you normalize for process size, the “die” gets bigger every time there’s a memory upgrade:</p><p><a onclick="javascript:pageTracker._trackPageview('/downloads/wp-content/uploads/2013/07/tumblr_mcaie92rL11qbs1hto1_400.png');" href="http://sealedabstract.com/wp-content/uploads/2013/07/tumblr_mcaie92rL11qbs1hto1_400.png"><img src="http://sealedabstract.com/wp-content/uploads/2013/07/tumblr_mcaie92rL11qbs1hto1_400.png" alt="normalized die size for iPhone chips" width="366" height="363" class="alignnone size-full wp-image-1931"></a></p><p>Silicon is an imperfect material, and bigger “good” pieces are exponentially expensive. They are also harder to keep cool and harder to fit in small devices. And they also have a lot of overlap with the problem of making better CPUs, because that is exactly what memory is: a top layer of CPU silicon that needs more transistors.</p><p>What I <strong>don’t</strong> know is why, in the face of these problems with PoP, manufacturers continue to use package-on-package delivery for system memory. I haven’t found an ARM engineer who can explain it to me yet. Perhaps one will show up in the comments. It may be that we could move away from PoP architecture and toward separate memory modules like you have in computers. But I suspect that it is not feasible, for the simple reason that breaking the memory into separate modules would almost certainly be cheaper to manufacture than bigger chips or process shrinks, yet every single manufacturer keeps doing process shrinks or bigger chips rather than moving memory modules off the die.</p><p>However, some smart engineers have e-mailed me to fill in some blanks.</p><p>An ex-Intel engineer:</p><blockquote><p>As for PoP memory, it’s a huge boost for latency and eases routing concerns. But I’m not an ARM guy, can’t say if that’s the full story.</p></blockquote><p>A robotics engineer:</p><blockquote><p>When PoP memory will not be enough, “3D” memory will be able to “give enough memory for everybody” : chips of memory stacked together as they are manufactured, with possibility to place 10+ layers of 1GB RAM in the same volume as current hardware. But : cost will be higher, frequency or voltage will have to drop to stay in the power limit.</p><p>Mobile RAM bandwidth will not continue to increase as much as it did recently. Bandwidth is limited by the number of lines linking the SoC and the RAM package. Currently, most of the periphery of high performing SoC is used for RAM bus lines. The middle of SoC can’t be used to add RAM lines due to the way the packages are stacked. Next big improvement will come from single package highly integrated SoC &amp; memory : SoC &amp; memory will be engineered together and stacked in the same package, allowing for much smaller, denser and numerous RAM lines (more bandwidth), more freedom for SoC design and possibly lower RAM voltage. With this type of design, bigger caches may be a possibility as some RAM may be put in the SoC die with even higher bandwidth.</p></blockquote><h3>But then how does Mono/Android/Windows Mobile do it?</h3><p>There are really two answers to this question. &nbsp;The first answer we can see from the chart. &nbsp;If you find yourself with 6 times as much memory as you need, garbage collection is actually going to be pretty fast. &nbsp;So for example, if you are writing a text editor, you might realistically be able to do everything you want in only 35MB, which is 1/6th the amount of memory before my iPhone 4S crashes. &nbsp;And you might write that text editor in Mono, see reasonable performance, and conclude from this exercise that garbage collectors are perfectly fine for this task, and you’d be right.</p><p>Yeah but Xamarin has <a onclick="javascript:pageTracker._trackPageview('/outgoing/xamarin.com/apps/app/infinite_flight_app');" href="http://xamarin.com/apps/app/infinite_flight_app">flight simulators in the showcase</a>! &nbsp;So clearly, the idea that garbage collectors are infeasible for larger apps flies in the face of real-life, large, garbage-collected mobile apps. &nbsp;<a onclick="javascript:pageTracker._trackPageview('/outgoing/conversations.nokia.com/2012/06/01/interview-with-matthieu-laban-infinite-flight-ceo/');" href="http://conversations.nokia.com/2012/06/01/interview-with-matthieu-laban-infinite-flight-ceo/">Or does it</a>?</p><blockquote><p>What sort of problems do you have to overcome when developing/maintaining this game? “Performance has been a big issue and continues to be one of the biggest problems we have across platforms. The original Windows Phone devices were pretty slow and we had to spend a lot of time optimising the app to get a descent frame rate. Optimisations were done both on the flight sim code as well as the 3D engine. The biggest bottlenecks were <strong>garbage collection</strong> and the weaknesses of the GPU.”</p></blockquote><p>Totally unprompted, the developers bring up garbage collection as the biggest bottleneck. &nbsp;When the people <span style="text-decoration: underline;">in your showcase</span> are complaining, that would be <strong>a clue</strong>. But maybe Xamarin is an outlier. &nbsp;Let’s <a onclick="javascript:pageTracker._trackPageview('/outgoing/www.war-worlds.com/blog/2012/06/on-android-garbage-collection-can-kill-you');" href="http://www.war-worlds.com/blog/2012/06/on-android-garbage-collection-can-kill-you">check in</a> on the Android developers:</p><blockquote><p>Now, keep in mind these are running my Galaxy Nexus — not a slow device by any stretch of the imagination. <em>But check out the rendering times!</em> While I was able to render these images in a couple of hundred milliseconds on my desktop, they were taking almost <strong>two orders of magnitude longer on the device</strong>! Over 6 seconds for the “inferno”? Crazy! &nbsp;…&nbsp;That’s 10-15 times the garbage collector would run to generate one image.</p></blockquote><p>Another <a onclick="javascript:pageTracker._trackPageview('/outgoing/nhenze.net/?p=349');" href="http://nhenze.net/?p=349">one</a>:</p><blockquote><p>If you want to process camera images on Android phones for real-time object recognition or content based Augmented Reality <strong>you probably heard about</strong> the Camera Preview Callback memory Issue. Each time your Java application gets a preview image from the system a new chunk of memory is allocated. When this memory chunk gets freed again by the Garbage Collector the system freezes for 100ms-200ms. This is especially bad if the system is under heavy load (I do object recognition on a phone – hooray it eats as much CPU power as possible). If you browse through Android’s 1.6 source code you realize that this is only because the wrapper (that protects us from the native stuff) allocates a new byte array each time a new frame is available. <strong>Build-in native code can, of course, avoid this issue</strong>.</p></blockquote><p>Or, we can consult <a onclick="javascript:pageTracker._trackPageview('/outgoing/stackoverflow.com/questions/2484079/how-can-i-avoid-garbage-collection-delays-in-java-games-best-practices');" href="http://stackoverflow.com/questions/2484079/how-can-i-avoid-garbage-collection-delays-in-java-games-best-practices">Stack Overflow</a>:</p><blockquote><p>I’m performance tuning interactive games in Java for the Android platform. Once in a while there is a hiccup in drawing and interaction for garbage collection. Usually it’s less than one tenth of a second, but sometimes it can be as large as 200ms on very slow devices…&nbsp;If I ever want trees or hashes in an inner loop I know that I need to be careful or even reimplement them instead of using the Java Collections framework since I can’t afford the extra garbage collection.</p></blockquote><p>Here’s the “accepted answer”, 27 votes:</p><blockquote><p>I’ve worked on Java mobile games… The best way to avoid GC’ing objects (which in turn shall trigger the GC at one point or another and shall kill your game’s perfs) is simply to avoid creating them in your main game loop in the first place.&nbsp;There’s no “clean” way to deal with this…&nbsp;<strong>Manual tracking of objects, sadly</strong>. This how it’s done on most current well-performing Java games that are out on mobile devices.</p></blockquote><p>Let’s check in with <a onclick="javascript:pageTracker._trackPageview('/outgoing/blog.crazybob.org/2011/12/truth-about-android-ios-ui-performance.html#1303002139217506150');" href="http://blog.crazybob.org/2011/12/truth-about-android-ios-ui-performance.html#1303002139217506150">Jon Perlow</a> of Facebook:</p><blockquote><p>GC is a huge performance problem for developing smooth android applications. At Facebook, one of the biggest performance problems we deal with is GCs pausing the UI thread. When dealing with lots of Bitmap data, GCs are frequent and hard to avoid. A single GC often results in dropped frames. Even if a GC only blocks the UI thread for a few milliseconds, it can significantly eat into the 16ms budget for rendering a frame.</p></blockquote><p>Okay, let’s check in with a <a onclick="javascript:pageTracker._trackPageview('/outgoing/geekswithblogs.net/mikebmcl/archive/2010/07/30/wp7-xna-the-gc-and-you-and-silverlight-too.aspx');" href="http://geekswithblogs.net/mikebmcl/archive/2010/07/30/wp7-xna-the-gc-and-you-and-silverlight-too.aspx">Microsoft MVP</a>:</p><blockquote><p>Normally your code will complete just fine within the 33.33 milliseconds, thereby maintaining a nice even 30FPS… However when the GC runs, it eats into that time. If you’ve kept the heap nice and simple …, the GC will run nice and fast and this likely won’t matter. But keeping a simple heap that the GC can run through quickly is a <strong>difficult programming task that requires a lot of planning and/or rewriting and even then isn’t fool proof</strong> (sometimes you just have a lot of stuff on the heap in a complex game with many assets). Much simpler, assuming you can do it, is to limit or <strong>even eliminate all allocations during gameplay</strong>.</p></blockquote><p>With garbage collection, <strong>the winning move is not to play</strong>. &nbsp;A weaker form of this “the winning move is not to play” philosophy is <a onclick="javascript:pageTracker._trackPageview('/outgoing/developer.android.com/training/articles/perf-tips.html');" href="http://developer.android.com/training/articles/perf-tips.html">embedded in the official Android documentation</a>:</p><blockquote><p>Object creation is never free. A generational garbage collector with per-thread allocation pools for temporary objects can make allocation cheaper, but allocating memory is always more expensive than not allocating memory. As you allocate more objects in your app, you will force a periodic garbage collection, creating little “hiccups” in the user experience. The concurrent garbage collector introduced in Android 2.3 helps, but unnecessary work should always be avoided. Thus, you should avoid creating object instances you don’t need to… Generally speaking, avoid creating short-term temporary objects if you can. Fewer objects created mean less-frequent garbage collection, which has a direct impact on user experience.</p></blockquote><p>Still not convinced? &nbsp;Let’s ask an <a onclick="javascript:pageTracker._trackPageview('/outgoing/blogs.msdn.com/b/abhinaba/archive/2009/03/02/back-to-basics-generational-garbage-collection.aspx');" href="http://blogs.msdn.com/b/abhinaba/archive/2009/03/02/back-to-basics-generational-garbage-collection.aspx">actual Garbage Collection engineer</a>. Who writes garbage collectors. For mobile devices. For a living. You know, the person whose <em>job it is</em> to know this stuff.</p><blockquote><p>However, with WP7 the capability of the device in terms of CPU and memory drastically increased. Games and large Silverlight applications started coming up which used close to 100mb of memory. As memory increases the number of references those many objects can have also <strong>increases exponentially</strong>. In the scheme explained above the GC has to traverse each and every object and their reference to mark them and later remove them via sweep. So the GC time also increases drastically and becomes a function of the net workingset of the application. This results in very large pauses in case of large XNA games and SL applications which finally manifests as long startup times (as GC runs during startup) or glitches during the game play/animation.</p></blockquote><p>Still not convinced? &nbsp;Chrome <a onclick="javascript:pageTracker._trackPageview('/outgoing/v8.googlecode.com/svn/branches/bleeding_edge/benchmarks/spinning-balls/index.html');" href="http://v8.googlecode.com/svn/branches/bleeding_edge/benchmarks/spinning-balls/index.html">has a benchmark</a> that measures GC performance. &nbsp;Let’s see how it does…</p><p><a onclick="javascript:pageTracker._trackPageview('/downloads/wp-content/uploads/2013/05/Photo-May-15-2-19-26-AM.png');" href="http://sealedabstract.com/wp-content/uploads/2013/05/Photo-May-15-2-19-26-AM.png"><img class="alignnone  wp-image-1730" alt="Photo May 15, 2 19 26 AM" src="http://sealedabstract.com/wp-content/uploads/2013/05/Photo-May-15-2-19-26-AM-1024x768.png" width="717" height="538"></a></p><p>That is a&nbsp;<strong>lot</strong> of GC pauses. &nbsp;Granted, this is a stress test–but still. &nbsp;You really want to wait a full second to render that frame? &nbsp;I think you’re nuts.</p><h3>Look, that’s a lot of quotes, I’m not reading all that. &nbsp;Get to the point.</h3><p>Here’s the point: memory management is&nbsp;<strong>hard</strong> on mobile. &nbsp;iOS has formed a culture around doing most things manually and trying to make the compiler do some of the easy parts. &nbsp;Android has formed a culture around improving a garbage collector that they try very hard not to use in practice. &nbsp;But either way, everybody spends a lot of time thinking about memory management when they write mobile applications. &nbsp;There’s just no substitute for <strong>thinking about memory</strong>. &nbsp;Like, a <em><span style="text-decoration: underline;"><strong>lot</strong></span></em>.</p><p>When JavaScript people or Ruby people or Python people hear “garbage collector”, they understand it to mean “<em>silver bullet</em> garbage collector.” &nbsp;They mean “garbage collector that frees me from thinking about managing memory.” &nbsp;But there’s no silver bullet on mobile devices. <strong>Everybody thinks about memory on mobile, whether they have a garbage collector or not</strong>. &nbsp;The only way to get “silver bullet” memory management is the same way we do it on the desktop–by having 10x more memory than your program really needs.</p><p>JavaScript’s whole design is based around not worrying about memory. &nbsp;<a onclick="javascript:pageTracker._trackPageview('/outgoing/groups.google.com/forum/?fromgroups=#!topic/chromium-extensions/XcS-RuQ0EWo');" href="https://groups.google.com/forum/?fromgroups=#!topic/chromium-extensions/XcS-RuQ0EWo">Ask the Chromium developers</a>:</p><blockquote><p>is there any way to force the chrome js engine to do Garbage&nbsp;Collection? &nbsp;In general, no, by design.</p></blockquote><p>The ECMAScript <a onclick="javascript:pageTracker._trackPageview('/outgoing/www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf');" href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf">specification</a> does not contain the word “allocation”, the only reference to “memory” essentially says that the entire subject is “host-defined”. &nbsp;</p><p>The ECMA 6 wiki has <a onclick="javascript:pageTracker._trackPageview('/outgoing/wiki.ecmascript.org/doku.php?id=strawman:gc_semantics&amp;s=garbage+collector');" href="http://wiki.ecmascript.org/doku.php?id=strawman:gc_semantics&amp;s=garbage+collector">several pages of draft proposal</a> that boil down to, and I am not kidding,</p><blockquote><p>“the garbage collector MUST NOT collect any storage that then becomes needed to continue correct execution of the program…&nbsp;All objects which are not transitively strongly reachable from roots SHOULD eventually be collected, if needed to prevent the program execution from failing due to memory exhaustion.”</p></blockquote><p>Yes, they actually are thinking about specifying this: a garbage collector should not collect things that it should not collect, but it should collect things it needs to collect. &nbsp;<a onclick="javascript:pageTracker._trackPageview('/outgoing/xkcd.com/703/');" href="http://xkcd.com/703/">Welcome to tautology club</a>. &nbsp;But perhaps more relevant to our purpose is this quote:</p><blockquote><p>However, there is no spec of how much actual memory any individual object occupies, <span style="text-decoration: underline;"><strong>nor is there likely to be</strong></span>. Thus we never have any guarantee when any program may exhaust its actual raw memory allotment, so all lower bound expectations are not precisely observable.</p></blockquote><p>In English: the philosophy of JavaScript (to the extent that it has any philosophy) is that <strong>you should not be able to observe what is going on in system memory, full stop</strong>. &nbsp;This is so&nbsp;<strong>unbelievably</strong> out of touch with how real people write mobile applications, I can’t even find the words to express it to you. &nbsp;I mean, in iOS world, we don’t believe in garbage collectors, and we think the Android guys are nuts. &nbsp;I suspect that the Android guys think the iOS guys are nuts for manual memory management. &nbsp;But you know what the two, cutthroat opposition camps can agree about? &nbsp;<strong>The JavaScript folks are really nuts</strong>. &nbsp;There is absolutely zero chance that you can write reasonable mobile code without worrying about what is going on in system memory, in some capacity. &nbsp;None. And so putting the whole question of SunSpider benchmarks and CPU-bound stuff fully aside, we arrive at the conclusion that <strong>JavaScript, at least as it stands today, is fundamentally opposed to the think-about-memory-philosophy that is absolutely required for mobile software development</strong>. &nbsp;</p><p>As long as people keep wanting to push mobile devices into these video and photo applications where desktops haven’t even been, and as long as mobile devices have a lot less memory to work with, the problem is just intractable. &nbsp;You need <em>serious, formal memory management guarantees</em> on mobile. &nbsp;And JavaScript, <strong>by design, refuses</strong> to provide them.</p><h2>Suppose it did</h2><p>Now you might say, “Okay. The JS guys are off in Desktop-land and are out of touch with mobile developers’ problems. But suppose they were convinced. Or, suppose somebody who actually <em>was</em> in touch with mobile developers’ problems forked the language. Is there something that can be done about it, in theory?”</p><p>I am not sure if it is solvable, but I can put some bounds on the problem. There is another group that has tried to fork a dynamic language to meet the needs of mobile developers–and <a onclick="javascript:pageTracker._trackPageview('/outgoing/www.rubymotion.com');" href="http://www.rubymotion.com">it’s called RubyMotion</a>.</p><p>So these are smart people, who know a lot about Ruby. And these <em>Ruby</em> people decided that garbage collection for their fork was A Bad Idea. (Hello GC advocates? Can you hear me?). So they have a thing that is a lot like ARC that they use instead, that they have sort of grafted on to the language. Turns out it <a onclick="javascript:pageTracker._trackPageview('/outgoing/joshsymonds.com/blog/2013/06/26/why-im-not-using-rubymotion-in-production/');" href="http://joshsymonds.com/blog/2013/06/26/why-im-not-using-rubymotion-in-production/">doesn’t work</a>:</p><blockquote><p>Summary: lots of people are experiencing memory-related issues that are a result of RM-3 or possibly some other difficult-to-identify problem with RubyMotion’s memory management, and they’re coming forward and talking about them.</p></blockquote><p>Ben Sheldon <a onclick="javascript:pageTracker._trackPageview('/outgoing/groups.google.com/forum/#!topic/rubymotion/x6-9c__IHH0');" href="https://groups.google.com/forum/#!topic/rubymotion/x6-9c__IHH0">weighs in</a>:</p><blockquote><p>It’s not just you. I’m experiencing these memory-related types of crashes (like SIGSEGV and SIGBUS) with about 10-20% of users in production.</p></blockquote><p>There’s some skepticism about whether the problem is tractable:</p><blockquote><p>I raised the question about RM-3 on the recent Motion Meetup and Laurent/Watson both responded (Laurent on camera, Watson in IRC). Watson mentioned that RM-3 is the toughest bug to fix, and Laurent discussed how he tried a few approaches but was never happy with them. Both devs are smart and strong coders, so I take them at their word.</p></blockquote><p>There’s some skepticism about whether the compiler can even solve it in theory:</p><blockquote><p>For a long while, I believed blocks could simply be something handled specifically by the compiler, namely the contents of a block could be statically analyzed to determine if the block references variables outside of its scope. For all of those variables, I reasoned, the compiler could simply retain each of them upon block creation, and then release each of them upon block destruction. This would tie the lifetime of the variables to that of the block (not the ‘complete’ lifetime in some cases, of course). One problem: instance_eval. The contents of the block may or may not be used in a way you can expect ahead of time.</p></blockquote><p>RubyMotion also has <a onclick="javascript:pageTracker._trackPageview('/outgoing/hipbyte.myjetbrains.com/youtrack/issue/RM-32');" href="http://hipbyte.myjetbrains.com/youtrack/issue/RM-32">the opposite problem</a>: it leaks memory. And maybe it has other problems. Nobody really knows if the crashes and leaks have 2 causes, or 200 causes. All we know is that people report both. A lot.</p><p>So anyway, here’s where we’re at: some of the best Ruby developers in the world have forked the language specifically for use on mobile devices, and they have designed a system that both crashes and leaks, which is the complete set of memory errors that you could possibly experience. So far they have not been able to do anything about it, although they have undoubtedly been trying very hard. Oh, and they are reporting that they “personally tried a few times to fix it, but wasn’t able to come with a good solution that would also perserve performance.”</p><p>I’m not saying forking JavaScript to get reasonable memory performance is impossible. I’m just saying there’s a lot of evidence that suggests the problem is <em>really hard</em>.</p><p>Update: A Rust contributor weighs in:</p><blockquote><p>I’m a contributor to the Rust project, whose goal is zero-overhead memory safety. We support GC’d objects via “@-boxes” (the type declaration is “@T” for any type T), and one thing we have been struggling with recently is that GC <em>touches everything in a language</em>. If you want to support GC but not require it, you need to very carefully design your language to support zero-overhead non-GC’d pointers. It’s a very non-trivial problem, and <strong>I don’t think it can be solved by forking JS</strong>.</p></blockquote><h3>Okay but what about asm.js</h3><p>asm.js is kind of interesting because it provides a JavaScript model that doesn’t, strictly speaking, rely on garbage collection. &nbsp;So in theory, with the right web browser, with the right APIs, it could be <em>okay</em>. The question is, “will we get the right browser?”</p><p>Mozilla is obviously sold on the concept, being the authors of the technology, and their implementation is landing later this year. Chrome’s reaction has been more mixed. &nbsp;It obviously competes with Google’s other proposals–Dart and PNaCl. &nbsp;There’s a <a onclick="javascript:pageTracker._trackPageview('/outgoing/code.google.com/p/v8/issues/detail?id=2599');" href="http://code.google.com/p/v8/issues/detail?id=2599">bug open about it</a>, but one of the V8 hackers <a onclick="javascript:pageTracker._trackPageview('/outgoing/mrale.ph/blog/2013/03/28/why-asmjs-bothers-me.html');" href="http://mrale.ph/blog/2013/03/28/why-asmjs-bothers-me.html">doesn’t like it</a>. &nbsp;With regard to the Apple camp, as best as I can tell, the WebKit folks are <a onclick="javascript:pageTracker._trackPageview('/outgoing/www.google.com/search?client=safari&amp;rls=en&amp;q=site:https://lists.webkit.org/pipermail/webkit-dev/+%22asm.js%22&amp;ie=UTF-8&amp;oe=UTF-8');" href="https://www.google.com/search?client=safari&amp;rls=en&amp;q=site:https://lists.webkit.org/pipermail/webkit-dev/+%22asm.js%22&amp;ie=UTF-8&amp;oe=UTF-8">completely silent</a>. &nbsp;IE? &nbsp;I wouldn’t get my hopes up.</p><p>Anyway, it’s not really clear why this is the One True Fixed JavaScript that will clearly beat all the competing proposals. &nbsp;In addition, if it did win–it really wouldn’t be JavaScript. &nbsp;After all, the whole reason it’s viable is that it potentially pries away that pesky garbage collector. &nbsp;Thus it could be viable with a C/C++ frontend, or some other manual-memory language. &nbsp;But it’s definitely not the same dynamic language we know and love today.</p><h1>Slow relative to WHAT</h1><p>One of the problems with these “X is slow” vs “X is not slow” articles is that nobody ever really states what their frame of reference is. &nbsp;If you’re a web developer, “slow” means something different than if you’re a high-performance cluster developer, means something different if you’re an embedded developer, etc. &nbsp;Now that we’ve been through the trenches and done the benchmarks, I can give you&nbsp;<strong>three frames of reference</strong> that are both&nbsp;<strong>useful</strong> and&nbsp;<strong>approximately correct</strong>.</p><p><strong>If you are a web developer</strong>, think about the iPhone 4S Nitro as IE8, as it benchmarks in the same class. &nbsp;That gets you in the correct frame of mind to write code for it. &nbsp;JS should be used very sparingly, or you will face numerous platform-specific hacks to make it perform. &nbsp;Some apps will just not be cost-effective to write for it, even though it’s a popular browser.</p><p><strong>If you are an x86 C/C++ developer</strong>, think about the iPhone 4S web development as a C environment that runs at 1/50th the speed of its desktop counterpart. &nbsp;Per the benchmarks, you incur a 10x performance penalty for being ARM, and another 5x performance penalty for being JavaScript. Now weigh the pros and cons of working in a non-JavaScript environment that is merely 10x slower than the desktop.</p><p><strong>If you are a Java, Ruby, Python, C# developer</strong>, think about iPhone 4S web development in the following way. &nbsp;It’s a computer that runs 10x slower than you expect (since ARM) and performance degrades exponentially if your memory usage goes above 35MB at any point, because that is how garbage collectors behave on the platform. &nbsp;Also, you get killed if at any point you allocate 213MB. &nbsp;And nobody will give you any information about this at runtime “by design”. &nbsp;Oh, and people keep asking you to write high-memory photo-processing and video applications in this environment.</p><h1>This is a really long article</h1><p>So here’s what you should remember:</p><ul><li><span style="line-height: 13px;">Javascript is too slow for mobile app use in 2013 (e.g., for photo editing etc.). &nbsp;</span><ul><li><span style="line-height: 13px;">It’s slower than native code by about 5</span></li><li>It’s comparable to IE8</li><li>It’s slower than x86 C/C++ by about 50</li><li>It’s slower than server-side Java/Ruby/Python/C# by a factor of about 10 if your program fits in 35MB, and it degrades exponentially from there</li></ul></li><li>The most viable path for it to get faster is by pushing the hardware to desktop-level performance. &nbsp;This might be viable long-term, but it’s looking like a pretty long wait.</li><li>The language itself doesn’t seem to be getting faster these days, and people who are working on it are saying that with the current language and APIs, it will never be as fast as native code</li><li>Garbage collection is exponentially bad in a memory-constrained environment. &nbsp;It is way, way worse than it is in desktop-class or server-class environments.</li><li>Every competent mobile developer, whether they use a GCed environment or not, spends a great deal of time thinking about the memory performance of the target device</li><li>JavaScript, as it currently exists, is fundamentally opposed to even allowing developers to think about the memory performance of the target device</li><li>If they did change their minds and allowed developers to think about memory, experience suggests this is a technically hard problem.</li><li>asm.js show some promise, but even if they win you will be using C/C++ or similar “backwards” language as a frontend, rather than something dynamic like JavaScript</li></ul><h1>Let’s raise the level of discourse</h1><p>I have no doubt that I am about to receive a few hundred emails that quote one of these “bullet points” and disagree with them, without either reference to any of the actual longform evidence that I’ve provided–or really an appeal to any evidence at all, other than “one time I wrote a word processor and it was fine” or “some people I’ve never met wrote a flight simulator and have never e-mailed me personally to talk about their performance headaches.” &nbsp;I will delete those e-mails.</p><p>If we are going to make any progress on the mobile web, or on native apps, or really on anything at all–we need to have conversations that at least&nbsp;<strong>appear</strong> to have a plausible basis in <em>facts of some kind</em>–benchmarks, journals, quotes from compiler authors, whatever. &nbsp;There have been enough HN comments about “I wrote a web app one time and it was fine”. &nbsp;There has been enough bikeshedding about whether Facebook was right or wrong to choose HTML5 or native apps knowing what they would have known then what they could have known now.</p><p>The task that remains for us is to&nbsp;<strong>quantify specifically</strong> how both the mobile web and the native ecosystem can get better, and then, you know, do something about it. &nbsp;You know–what software developers <em>do</em>.</p><hr><p>Thanks for making it all the way to the end of this article! If you enjoyed this read, <strong>you should <a onclick="javascript:pageTracker._trackPageview('/outgoing/twitter.com/drewcrawford');" href="http://twitter.com/drewcrawford">follow me on Twitter (@drewcrawford)</a></strong>, <a onclick="javascript:pageTracker._trackPageview('/mailto/drew@sealedabstract.com');" href="mailto:drew@sealedabstract.com">send me an email</a>, subscribe via RSS, or leave a comment, and share my writing with your friends. It takes many, many hours to write and research this sort of article, and all I get in return are the kind words of my readers. I have many articles of similar depth at various stages of composition, and when I know that people enjoy them it motivates me to invest the time. Thanks for being such a great audience!</p></div>
